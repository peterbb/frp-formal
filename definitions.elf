
nat : type.

nat/0 : nat.
nat/s : nat -> nat.

neq-nat : nat -> nat -> type.
%mode neq-nat +N +M.

% --------------------------------------------------
neq-nat/s-0 : neq-nat (nat/s N) nat/0.
neq-nat/0-s : neq-nat nat/0 (nat/s M).
neq-nat/s-s : neq-nat (nat/s N) (nat/s M)
    <- neq-nat N M.

%worlds () (neq-nat _ _).

% --------------------------------------------------
tp : type.

tp/bool   : tp.
tp/nat    : tp.
tp/prod   : tp -> tp -> tp.
tp/sum    : tp -> tp -> tp.
=>        : tp -> tp -> tp.     %infix right 10 =>.
tp/next   : tp -> tp.
tp/stable : tp -> tp.
tp/mu     : (tp -> tp) -> tp.
tp/S      : tp -> tp.
tp/alloc  : tp.

% --------------------------------------------------
tm : type.

tm/zero        : tm.
tm/succ        : tm -> tm.
tm/nat-rec     : tm -> tm -> (tm -> tm) -> tm.
tm/true        : tm.
tm/false       : tm.
tm/if          : tm -> tm -> tm -> tm.
tm/fst         : tm -> tm.
tm/snd         : tm -> tm.
tm/pair        : tm -> tm -> tm.
tm/inl         : tm -> tm.
tm/inr         : tm -> tm.
tm/case        : tm -> (tm -> tm) -> (tm -> tm) -> tm.
tm/lam         : (tm -> tm) -> tm.
tm/app         : tm -> tm -> tm.
tm/delta       : tm -> tm -> tm.
tm/delta-let   : tm -> (tm -> tm) -> tm.
tm/stable      : tm -> tm.
tm/stable-let  : tm -> (tm -> tm) -> tm.
tm/into        : tm -> tm.
tm/out         : tm -> tm.
tm/cons        : tm -> tm -> tm.
tm/cons-let    : tm -> (tm -> tm -> tm) -> tm.
tm/fix         : (tm -> tm) -> tm.
tm/promote     : tm -> tm.
tm/ptr         : nat -> tm.
tm/ptr-ref     : nat -> tm.
tm/alloc       : tm.

% --------------------------------------------------
val : tm -> type.

val/true : val tm/true.

val/false : val tm/false.

val/zero : val tm/zero.

val/succ : val (tm/succ V)
    <- val V.

val/pair   : val (tm/pair V1 V2)
    <- val V2
    <- val V1.

val/inl    : val (tm/inl V)
    <- val V.

val/inr    : val (tm/inr V)
    <- val V.

val/lam    : val (tm/lam E).

val/ptr    : {l} val (tm/ptr l).

val/alloc  : val tm/alloc.

val/stable : val (tm/stable V)
    <- val V.

val/into   : val (tm/into V)
    <- val V.

val/cons   : val (tm/cons V1 V2)
    <- val V2
    <- val V1.

% --------------------------------------------------
store : type. %name store Sigma.

store/empty : store.
store/now   : store -> nat -> val V -> store.
store/later : store -> nat -> tm -> store.
store/null  : store -> nat -> store.

store-lookup-now : store -> nat -> val V -> type.
%mode store-lookup-now +Sigma +L -V.

% --------------------------------------------------
store-conc : store -> store -> store -> type.
%mode store-conc +Sigma +Sigma' -Sigma''.

store-conc/empty : store-conc Sigma store/empty Sigma.

store-conc/now : store-conc Sigma (store/now Sigma' L V)
                            (store/now Sigma'' L V)
    <- store-conc Sigma Sigma' Sigma''.

store-conc/later : store-conc Sigma (store/later Sigma' L V)
                              (store/later Sigma'' L V)
    <- store-conc Sigma Sigma' Sigma''.

store-conc/null : store-conc Sigma (store/null Sigma' L)
                             (store/null Sigma'' L)
    <- store-conc Sigma Sigma' Sigma''.

%worlds () (store-conc _ _ _).
%total (Sigma') (store-conc _ Sigma' _).

% --------------------------------------------------
store-lookup-now/hyp : store-lookup-now (store/now Sigma L V) L V.

store-lookup-now/now : store-lookup-now (store/now Sigma L' V') L V
    <- neq-nat L L'
    <- store-lookup-now Sigma L V.

store-lookup-now/later : store-lookup-now (store/later Sigma L' V') L V
    <- store-lookup-now Sigma L V.

store-lookup-now/null : store-lookup-now (store/null Sigma L') L V
    <- store-lookup-now Sigma L V.

% --------------------------------------------------
fresh : store -> nat -> type.

fresh/empty : fresh store/empty L.

fresh/now : fresh (store/now Sigma L' V) L
    <- fresh Sigma L
    <- neq-nat L L'.

fresh/later : fresh (store/later Sigma L' E) L
    <- fresh Sigma L
    <- neq-nat L L'.

fresh/null : fresh (store/null Sigma L') L
    <- fresh Sigma L
    <- neq-nat L L'.

% --------------------------------------------------
ctx : type.

ctx/empty  : ctx.
ctx/now    : ctx -> tm -> tp -> ctx.
ctx/stable : ctx -> tm -> tp -> ctx.
ctx/later  : ctx -> tm -> tp -> ctx.

% --------------------------------------------------
ctx-lookup : ctx -> tm -> tp -> type.

ctx-lookup/now-found : ctx-lookup (ctx/now Sigma X A) X A.

ctx-lookup/stable-found : ctx-lookup (ctx/stable Sigma X A) X A.

ctx-lookup/now : ctx-lookup (ctx/now Gamma X' B) X A
    <- ctx-lookup Gamma X A.

ctx-lookup/stable : ctx-lookup (ctx/stable Gamma X' B) X A
    <- ctx-lookup Gamma X A.

ctx-lookup/later : ctx-lookup (ctx/later Gamma X' B) X A
    <- ctx-lookup Gamma X A.
    
% --------------------------------------------------
ctx* : ctx -> ctx -> type.
%mode ctx* +Gamma -Delta.

ctx*/empty  : ctx* ctx/empty ctx/empty.
ctx*/now    : ctx* (ctx/now Gamma _ _) Delta
    <- ctx* Gamma Delta.
ctx*/stable : ctx* (ctx/stable Gamma X A) (ctx/stable Delta X A)
    <- ctx* Gamma Delta.
ctx*/later  : ctx* (ctx/later Gamma X A) (ctx/now Delta X A)
    <- ctx* Gamma Delta.

%worlds () (ctx* _ _).
%total Gamma (ctx* Gamma _).

% --------------------------------------------------
ctx# : ctx -> ctx -> type.
%mode ctx# +Gamma -Delta.

ctx#/empty  : ctx# ctx/empty ctx/empty.
ctx#/now    : ctx# (ctx/now Gamma _ _) Delta
    <- ctx# Gamma Delta.
ctx#/later  : ctx# (ctx/later Gamma _ _) Delta
    <- ctx# Gamma Delta.
ctx#/stable : ctx# (ctx/stable Gamma X A) (ctx/stable Delta X A)
    <- ctx# Gamma Delta.

%worlds () (ctx# _ _).
%total Gamma (ctx# Gamma _).

% --------------------------------------------------
stable : tp -> type.
%mode stable +A.

stable/bool : stable tp/bool.

stable/nat : stable tp/nat.

stable/prod : stable (tp/prod A B)
    <- stable A
    <- stable B.

stable/sum : stable (tp/sum A B)
    <- stable A
    <- stable B.

stable/stable : stable (tp/stable A).

% --------------------------------------------------
of-now    : ctx -> tm -> tp -> type.
of-stable : ctx -> tm -> tp -> type.
of-later  : ctx -> tm -> tp -> type.

of-now/bool-it : of-now Gamma tm/true tp/bool.

of-now/bool-if : of-now Gamma tm/false tp/bool.

of-now/bool-e : of-now Gamma (tm/if E Et Ef) C
    <- of-now Gamma E tp/bool
    <- of-now Gamma Et C
    <- of-now Gamma Ef C.

of-now/nat-iz : of-now Gamma tm/zero tp/nat.

of-now/nat-is : of-now Gamma (tm/succ E) tp/nat
    <- of-now Gamma E tp/nat.

of-now/nat-e : of-now Gamma (tm/nat-rec E Ez Es) C
    <- of-now Gamma E tp/nat
    <- of-now Gamma Ez C
    <- ({x} of-now (ctx/now Gamma x tp/nat) (Es x) C).

of-now/pair-i : of-now Gamma (tm/pair E E') (tp/prod A B)
    <- of-now Gamma E A
    <- of-now Gamma E' B.

of-now/pair-el : of-now Gamma (tm/fst E) A
    <- of-now Gamma E (tp/prod A B).

of-now/pair-er : of-now Gamma (tm/snd E) B
    <- of-now Gamma E (tp/prod A B).

of-now/sum-il : of-now Gamma (tm/inl E) (tp/sum A B)
    <- of-now Gamma E A.

of-now/sum-ir : of-now Gamma (tm/inr E) (tp/sum A B)
    <- of-now Gamma E B.

of-now/sum-e : of-now Gamma (tm/case E E' E'') C
    <- of-now Gamma E (tp/sum A B)
    <- ({x} of-now (ctx/now Gamma x A) (E' x) C)
    <- ({y} of-now (ctx/now Gamma y B) (E'' y) C).

of-now/=>-i : of-now Gamma (tm/lam E) (A => B)
    <- ({x} of-now (ctx/now Gamma x A) (E x) B).

of-now/=>-e : of-now Gamma (tm/app E E') B
    <- of-now Gamma E (A => B)
    <- of-now Gamma E' A.

of-now/next-i : of-now Gamma (tm/delta E' E) (tp/next A)
    <- of-later Gamma E A
    <- of-now Gamma E' tp/alloc.

of-now/next-e : of-now Gamma (tm/delta-let E E') C
    <- of-now Gamma E (tp/next A)
    <- ({x} of-now (ctx/later Gamma x A) (E' x) C).

of-now/mu-i : of-now Gamma (tm/into E) (tp/mu A)
    <- of-now Gamma E (A (tp/next (tp/mu A))).

of-now/mu-e : of-now Gamma (tm/out E) (A (tp/next (tp/mu A)))
    <- of-now Gamma E (tp/mu A).

of-now/stable-i : of-now Gamma (tm/stable E) (tp/stable A)
    <- of-stable Gamma E A.

of-now/stable-e : of-now Gamma (tm/stable-let E E') C
    <- of-now Gamma E (tp/stable A)
    <- ({x} of-now (ctx/stable Gamma x A) (E' x) C).

of-now/promote : of-now Gamma (tm/promote E) (tp/stable A)
    <- stable A
    <- of-now Gamma E A.

of-now/S-i : of-now Gamma (tm/cons E E') (tp/S A)
    <- of-now Gamma E A
    <- of-now Gamma E' (tp/next (tp/S A)).

of-now/S-e : of-now Gamma (tm/cons-let E E') C
    <- of-now Gamma E (tp/S A)
    <- ({x}{xs} of-now (ctx/now (ctx/now Gamma x A) xs (tp/next (tp/S A)))
                       (E' x xs) C).      

of-now/fix : of-now Gamma (tm/fix E) A
    <- ctx# Gamma Gamma#
    <- ({x} of-now (ctx/later Gamma# x A) (E x) A).

of-now/hyp : of-now Gamma X A
    <- ctx-lookup Gamma X A.

of-stable/intro : of-stable Gamma E A
    <- ctx# Gamma Gamma#
    <- of-now Gamma# E A.

of-later/intro : of-later Gamma E A
    <- ctx* Gamma Gamma*
    <- of-now Gamma* E A.

% --------------------------------------------------
eval : store -> tm -> store -> val V -> type.

eval/refl : {V : val E} eval Sigma E Sigma V.

eval/if-true : eval Sigma (tm/if E E' _) Sigma'' V
    <- eval Sigma E Sigma' val/true
    <- eval Sigma' E' Sigma'' V.

eval/if-false : eval Sigma (tm/if E _ E') Sigma'' V
    <- eval Sigma E Sigma' val/false
    <- eval Sigma' E' Sigma'' V.

eval/succ : eval Sigma (tm/succ E) Sigma' (val/succ V)
    <- eval Sigma E Sigma' V.

eval/nat-rec-zero : eval Sigma (tm/nat-rec E Ez _) Sigma'' V
    <- eval Sigma E Sigma' val/zero
    <- eval Sigma' Ez Sigma'' V.

eval/nat-rec-succ : eval Sigma (tm/nat-rec E _ Es) Sigma'' V'
    <- eval Sigma E Sigma' (val/succ _ : val (tm/succ V))
    <- eval Sigma' (Es V) Sigma'' V'.

eval/pair : eval Sigma (tm/pair E1 E2) Sigma'' (val/pair V1 V2)
    <- eval Sigma E1 Sigma' V1
    <- eval Sigma' E2 Sigma'' V2.

eval/fst : eval Sigma (tm/fst E) Sigma' V1
    <- eval Sigma E Sigma' (val/pair V1 _).

eval/snd : eval Sigma (tm/snd E) Sigma' V2
    <- eval Sigma E Sigma' (val/pair _ V2).

eval/inl : eval Sigma (tm/inl E) Sigma' (val/inl V)
    <- eval Sigma E Sigma' V.

eval/inr : eval Sigma (tm/inr E) Sigma' (val/inr V)
    <- eval Sigma E Sigma' V.

eval/case-inl : eval Sigma (tm/case E-sum E-left E-right) Sigma'' V
    <- eval Sigma E-sum Sigma' (val/inl _ : val (tm/inl E))
    <- eval Sigma' (E-left E) Sigma'' V.

eval/case-inr : eval Sigma (tm/case E-sum E-left E-right) Sigma'' V
    <- eval Sigma E-sum Sigma' (val/inr _ : val (tm/inr E))
    <- eval Sigma' (E-right E) Sigma'' V.

eval/app : eval Sigma (tm/app E1 E2) Sigma''' V'
    <- eval Sigma E1 Sigma' (val/lam : val (tm/lam E))
    <- eval Sigma' E2 Sigma'' (_ : val V)
    <- eval Sigma'' (E V) Sigma''' V'.

eval/delta : eval Sigma (tm/delta E' E) (store/later Sigma' L E) (val/ptr L)
    <- eval Sigma E' Sigma' val/alloc
    <- fresh Sigma' L.

eval/delta-let : eval Sigma (tm/delta-let E E') Sigma'' V
    <- eval Sigma E Sigma' (val/ptr L) 
    <- eval Sigma' (E' (tm/ptr-ref L)) Sigma'' V.

eval/ptr-ref : eval Sigma (tm/ptr-ref L) Sigma V
    <- store-lookup-now Sigma L V.

eval/into : eval Sigma (tm/into E) Sigma' (val/into V)
    <- eval Sigma E Sigma' V.

eval/out : eval Sigma (tm/out E) Sigma' V
    <- eval Sigma E Sigma' (val/into V).

eval/stable : eval Sigma (tm/stable E) Sigma' (val/stable V)
    <- eval Sigma E Sigma' V.

eval/promote : eval Sigma (tm/promote E) Sigma' (val/stable V)
    <- eval Sigma E Sigma' V.

eval/stable-let : eval Sigma (tm/stable-let E E') Sigma'' V''
    <- eval Sigma E Sigma' (val/stable _ : val (tm/stable V))
    <- eval Sigma' (E' V) Sigma'' V''.

eval/cons : eval Sigma (tm/cons E E') Sigma'' (val/cons V V')
    <- eval Sigma E Sigma' V
    <- eval Sigma' E' Sigma'' V'.

eval/cons-let : eval Sigma (tm/cons-let E E') Sigma'' V
    <- eval Sigma E Sigma' (val/cons _ _ : val (tm/cons X XS))
    <- eval Sigma' (E' X XS) Sigma'' V.

eval/fix : eval Sigma (tm/fix E) Sigma' V
    <- eval Sigma (E (tm/fix E)) Sigma' V.


% --------------------------------------------------
===> : store -> store -> type. %infix none 10 ===>.

===>/empty : store/empty ===> store/empty.

===>/later : (store/later Sigma L E) ===> (store/now Sigma'' L V)
    <- Sigma ===> Sigma'
    <- eval Sigma' E Sigma'' V
    <- fresh Sigma'' L.

===>/now : (store/now Sigma L V) ===> (store/null Sigma' L)
    <- Sigma ===> Sigma'
    <- fresh Sigma' L.

===>/null : (store/null Sigma L) ===> (store/null Sigma' L)
    <- Sigma ===> Sigma'
    <- fresh Sigma' L.

